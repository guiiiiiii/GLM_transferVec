#define GLM_ENABLE_EXPERIMENTAL
#include "glm/glm.hpp"	// glm ê¸°ë³¸ í•¨ìˆ˜
#include "glm/ext.hpp"	// glm í™•ì¥ í•¨ìˆ˜
#include <math.h>	
#include <iostream>	
#include <string>	

using namespace glm;

int main(int argc, char** argv)
{
	std::cout << "1ë²ˆ" << std::endl;
	//ğ‘˜a ğ¼ğ‘ + ğ‘˜ğ‘‘ ğ¼ğ‘™ (ğ‘í–‡ âˆ™ ğ¿í–‡) + ğ‘˜ğ‘  ğ¼ğ‘™ (ğ‘…í–‡ âˆ™ ğ‘‰í–‡)
	//ğ‘˜ğ‘ = 0.2, ğ‘˜ğ‘‘ = 0.8, ğ‘˜ğ‘  = 0.5
	//ğ¼ğ‘ = 0.5, 0.1, 0.1
	//ğ¼ğ‘™ = 0.9, 0.2, 0.2
	//ğ‘ = 0.1, 0.99, 0.1
	//ğ¿ = 100, 100, 100
	//ğ‘… = âˆ’100, 100, âˆ’100
	//ğ‘‰ = 0, 10, âˆ’100
	//ğ‘› = 20

	//ì—°ì‚°ì— ì‚¬ìš©í•  ë³€ìˆ˜ì„ ì–¸ê³¼ ì´ˆê¸°í™”
	float ka = 0.2f, kd = 0.8f, ks = 0.5f;
	glm::vec3 Ia(0.5f, 0.1f, 0.1f);
	glm::vec3 Il(0.9f, 0.2f, 0.2f);
	glm::vec3 N(0.1f, 0.99f, 0.1f);
	glm::vec3 L(100.f, 100.f, 100.f);
	glm::vec3 R(-100.f, 100.f, -100.f);
	glm::vec3 V(0.f, 10.f, -100.f);
	float n = 20.f;

	//ì—°ì‚°í•˜ê¸° ìœ„í•´ ë‹¨ìœ„ë²¡í„° ê³„ì‚°
	glm::vec3 unitN = glm::normalize(N);
	glm::vec3 unitL = glm::normalize(L);
	glm::vec3 unitR = glm::normalize(R);
	glm::vec3 unitV = glm::normalize(V);

	float dotNL = glm::dot(unitN, unitL);
	float dotRV = glm::dot(unitR, unitV);

	glm::vec3 result = ka * Ia + kd * dotNL *Il + ks * pow(dotRV, n)*Il;

	std::cout << "ê³„ì‚° ê²°ê³¼ : " << glm::to_string(result) << std::endl;

	std::cout << "2ë²ˆ"; 

					   //2. Rotate by 45Â°
					   //	about z - axis
					   //	2. Scale by 2 in the y - axis
					   //	3. Translate by - 5 in the x - axis

					   //	â€¢ ğ©ğŸ = (ğŸ, ğŸ, ğŸ)
					   //	â€¢ ğ©ğŸ = (ğŸ, ğŸ, ğŸ)
					   //	â€¢ ğ©ğŸ = (ğŸ, ğŸ, ğŸ)
					   //	â€¢ ğ©ğŸ‘ = (ğŸ, ğŸ‘, ğŸ)
					   //	â€¢ ğ©ğŸ’ = (ğŸ, ğŸ, ğŸ)

	glm::vec4 p0(0.f, 0.f, 0.f, 1.f); //3ì°¨ì›ë²¡í„°ì§€ë§Œ ëª¨ë“  ë³€í™˜í–‰ë ¬ì„ í•˜ë‚˜ì˜ í–‰ë ¬ê³±ìœ¼ë¡œ ë‚˜íƒ€ë‚´ì£¼ê¸° ìœ„í•˜ì—¬ í•˜ë‚˜ì˜ ê°’ì„ ì¶”ê°€, 4ì°¨ì›ìœ¼ë¡œ ì‚¬ìš©
	glm::vec4 p1(2.f, 0.f, 0.f, 1.f);
	glm::vec4 p2(2.f, 2.f, 0.f, 1.f);
	glm::vec4 p3(1.f, 3.f, 0.f, 1.f);
	glm::vec4 p4(0.f, 2.f, 0.f, 1.f);

	glm::mat4 A = glm::rotate(glm::radians(45.f), glm::vec3(0.f, 0.f, 1.f)); //z-axisì´ë¯€ë¡œ (0,0,1)
	glm::mat4 B = glm::scale(glm::vec3(1.f, 2.f, 1.f)); //yì¶•ìœ¼ë¡œ 2ë§Œí¼ì´ë¯€ë¡œ (1,2,1)
	glm::mat4 C = glm::translate(glm::vec3(-5.f, 0.f, 0.f)); //xì¶•ìœ¼ë¡œ -5ë§Œí¼ ì´ë¯€ë¡œ (-5,0,0)

	glm::mat4 T = C * B * A;  //rotate->scale->translateì´ë¯€ë¡œ í–‰ë ¬ê³± ìˆœìœ¼ë¡œ ë‚˜ì—´í•˜ì—¬ ë³€í™˜í–‰ë ¬ ì •ì˜

	//transform

	glm::vec4 t_p0 = T * p0;
	glm::vec4 t_p1 = T * p1;
	glm::vec4 t_p2 = T * p2;
	glm::vec4 t_p3 = T * p3;
	glm::vec4 t_p4 = T * p4;

	std::cout << "p0 : " << glm::to_string(t_p0) << std::endl;
	std::cout << "p1 : " << glm::to_string(t_p1) << std::endl;
	std::cout << "p2 : " << glm::to_string(t_p2) << std::endl;
	std::cout << "p3 : " << glm::to_string(t_p3) << std::endl;
	std::cout << "p4 : " << glm::to_string(t_p4) << std::endl;


	return 0;
}




